# Simple git colored branch status in Bash prompt.
# Version: 1.0
#
# Requires Git, Bash and terminal with color support. This file should be
# source'd from ~/.bashrc or similar *after* your initial PS1 prompt setup. It
# may not be able to inject status before your prompt suffix ('$ ', etc),
# depending on use of colors and non-standard formatting. In that case, the git
# status is simply appended. Note that altering PS1 *after* enabling this code
# will currently not work properly without unsetting '_BASHGIT_ORIG' first.
#
# Minimum required git version is 1.7.2.
#
# Tries to be reasonably efficient with few forks and use of Bash builtins where
# possible.
#
# Displays color coded name of current branch (or best description if detached
# HEAD or tag), and optionally number of commits ahead/behind a remote tracking
# branch. Green for clean, red for uncomitted changes etc., yellow for work tree
# modifications and/or unknowns. Does branch name truncation to keep prompt from
# growing too much.
#
# The following git config options are understood by bashgit:
# - bashgit.showremote    (boolean) show remote ahead/behind status in prompt or not
# - bashgit.branchlimit   (integer) max branch name length in prompt
# - bashgit.untracked     (boolean) include untracked files as dirty state, false
#                         gives better performance with large repositories.
# 
# Author: Ã˜yvind Stegard <oyvind.stegard@ifi.uio.no>

declare _BASHGIT_ORIG                # Original PS1

_bashgit_set_prompt() {
    type git &>/dev/null || return 1

    local   light_red='\[\033[1;31m\]'
    local         red='\[\033[0;31m\]'
    local light_green='\[\033[1;32m\]'
    local       green='\[\033[0;32m\]'
    local      yellow='\[\033[0;33m\]'
    local        blue='\[\033[0;34m\]'
    local       white='\[\033[1;37m\]'
    local   dark_gray='\[\033[1;30m\]'
    local  color_none='\[\033[0m\]'

    local IFS=$'\n' line state branch= remote_state=0 pattern

    # Initial check if index dirty state
    git diff-index --quiet --cached HEAD 2>/dev/null
    case $? in
        0) state="$green";;
        1) state="$red";;
        *) # Likely not in a git work tree
           [ "$_BASHGIT_ORIG" ] && PS1="$_BASHGIT_ORIG"  
           return 2
           ;;
    esac

    # Options
    local untracked branchlimit showremote
    untracked=$(git config --bool bashgit.untracked 2>/dev/null)
    branchlimit=$(git config --int bashgit.branchlimit 2>/dev/null)
    showremote=$(git config --bool bashgit.showremote 2>/dev/null)
    [ "$untracked" = false ] && untracked=no || untracked=normal
    [ "$branchlimit" ] || branchlimit=22
    [ "$showremote" = false ] && showremote= || showremote=true
    
    # Invoke git status
    for line in $(git status --porcelain -b -u${untracked} 2>/dev/null); do
        pattern='^## ([^. ]*)(\.\.\.([^ ]*))?'
        if [ -z "$branch" ] && [[ $line =~ $pattern ]]; then
            branch="${BASH_REMATCH[1]}"
            if [ "${BASH_REMATCH[3]}" ]; then
                # Check ahead/behind/divergence from remote tracking branch
                pattern='ahead ([0-9]*)'
                if [[ $line =~ $pattern ]]; then
                    remote_state=${BASH_REMATCH[1]} # ahead
                fi
                pattern='behind ([0-9]*)'
                if [[ $line =~ $pattern ]]; then
                    if [ $remote_state != 0 ]; then
                        remote_state="$remote_state,-${BASH_REMATCH[1]}" # divergence
                    else
                        remote_state="-${BASH_REMATCH[1]}" # behind (negative number)
                    fi
                fi
            fi
            [ "$state" = "$red" ] && break || continue
        fi
        if [ "${line#[ ?][MD?] }" != "$line" ]; then
            state="$yellow" # work tree changes and/or untracked files
            break
        fi
    done
    IFS=$' \t\n'

    if [ -z "$branch" ]; then
        # git invocation failed, likely not inside a git work tree, cancel prompt injection.
        [ "$_BASHGIT_ORIG" ] && PS1="$_BASHGIT_ORIG"
        return 2
    elif [ "$branch" = HEAD ]; then
        # Unknown branch/detached HEAD
        # Try git-describe to get at most recent tag reachable from HEAD commit
        branch="$(git describe HEAD --always --tags 2>/dev/null)" || branch=HEAD
    fi

    local remote=
    if [ $remote_state != '0' ] && [ "$showremote" ]; then
        remote="|${dark_gray}${remote_state}${state}"
    fi

    # Branch name truncation
    if [ $branchlimit -gt 0 ] && [ ${#branch} -gt $branchlimit ]; then
        pattern='^([^/]*)/([^/]*)$'
        if [[ ${branch} =~ $pattern ]]; then
            local branch_prefix=${BASH_REMATCH[1]}
            local branch_name=${BASH_REMATCH[2]}
            if [ ${#branch_prefix} -gt 3 ]; then
                branch="${branch_prefix:0:3}/${branch_name}"
            fi
        fi
        if [ ${#branch} -gt $branchlimit ]; then
            branch="${branch:0:${branchlimit}}.."
        fi
    fi

    # Preserve original PS1 before inject
    [ "$_BASHGIT_ORIG" ] || _BASHGIT_ORIG=$PS1

    # Injection before prompt suffix if possible
    case $_BASHGIT_ORIG in
        *'\$ ') PS1="${_BASHGIT_ORIG%\\\$ }${state}[${branch}${remote}]${color_none}\\\$ " ;;
        *'$ ') PS1="${_BASHGIT_ORIG%\$ }${state}[${branch}${remote}]${color_none}\$ " ;;
        *'# ') PS1="${_BASHGIT_ORIG%# }${state}[${branch}${remote}]${color_none}# " ;;
        *) PS1="${_BASHGIT_ORIG}${state}[${branch}${remote}]${color_none} " ;;
    esac
}

# Invoke git status before prompt display:
if [ "${PROMPT_COMMAND//_bashgit_set_prompt}" = "$PROMPT_COMMAND" ]; then
    PROMPT_COMMAND="_bashgit_set_prompt; $PROMPT_COMMAND"
fi
