# Simple colored git branch status in Bash prompt.
# Version: 1.0
#
# Requires Git >= 1.7.2, Bash and terminal with color support. This file should
# be source'd from ~/.bashrc or similar *after* your initial PS1 prompt setup.
# It may not be able to inject status before your prompt suffix ('$ ', etc),
# depending on use of colors and non-standard formatting. In that case, the git
# status is simply appended.
#
# Tries to be reasonably efficient with use of shell builtins where possible.
#
# Displays color coded name of current branch (or best description if detached
# HEAD or tag), and optionally number of commits ahead/behind a remote tracking
# branch. Green for clean, red for uncomitted changes etc., yellow for work tree
# modifications and/or unknowns. Does branch name truncation to keep prompt from
# growing too much.
#
# Examples: [master|1,-2]          # 1 ahead, 2 behind remote tracking branch
#           [bug/branch-na..]      # truncated form for branch "bugfix/branch-name".
#
# The following git config options are understood by bashgit:
# - bashgit.showremote    (boolean) show remote ahead/behind status in prompt or not
# - bashgit.branchlimit   (integer) max branch name length in prompt
# - bashgit.untracked     (boolean) include untracked files as dirty state, false
#                         gives better performance with large repositories.
# 
# Author: Ã˜yvind Stegard <oyvind.stegard@ifi.uio.no>

# Globals
declare _BASHGIT_PS1_ORIG    # Original PS1
declare _BASHGIT_PS1_PREV    # Previous PS1, may include injected bashgit status.

_bashgit_update_ps1() {
    type git &>/dev/null || return 1

    local         red='\[\e[0;31m\]'
    local       green='\[\e[0;32m\]'
    local      yellow='\[\e[0;33m\]'
    local   dark_gray='\[\e[1;30m\]'
    local  color_none='\[\e[0m\]'

    if [ -z "${_BASHGIT_PS1_PREV+x}" ] || [ "$PS1" != "$_BASHGIT_PS1_PREV" ]; then
        _BASHGIT_PS1_ORIG=$PS1
        _BASHGIT_PS1_PREV=$PS1
    fi

    local IFS=$'\n' line state branch= remote_state= pattern
    # Initial check if index dirty state
    git diff-index --quiet --cached HEAD 2>/dev/null
    case $? in
        0) state="$green";;
        1) state="$red";;
        *) # Likely not in a git work tree
           [ "$_BASHGIT_PS1_ORIG" ] && PS1=$_BASHGIT_PS1_ORIG
           return 2
           ;;
    esac

    # User options
    local untracked branchlimit showremote
    untracked=$(git config --bool bashgit.untracked 2>/dev/null)
    branchlimit=$(git config --int bashgit.branchlimit 2>/dev/null)
    showremote=$(git config --bool bashgit.showremote 2>/dev/null)
    [ "$untracked" = false ] && untracked=no || untracked=normal
    [ "$branchlimit" ] || branchlimit=22
    [ "$showremote" = false ] && showremote= || showremote=true
    
    # Invoke git status
    for line in $(git status --porcelain -b -u${untracked} 2>/dev/null); do
        if [ -z "$branch" ] && [ "${line:0:3}" = '## ' ]; then
            line=${line:3}
            branch=${line%...*}
            if [ "$branch" != "$line" ]; then
                # Check ahead/behind/divergence from remote tracking branch
                pattern='ahead ([0-9]*)'
                if [[ $line =~ $pattern ]]; then
                    remote_state=${BASH_REMATCH[1]} # ahead
                fi
                pattern='behind ([0-9]*)'
                if [[ $line =~ $pattern ]]; then
                    remote_state="${remote_state:+$remote_state,}-${BASH_REMATCH[1]}" # behind
                fi
            else
                branch=${branch%% *}
            fi
            [ "$state" = "$red" ] && break || continue
        fi
        if [ "${line#[ ?][MD?] }" != "$line" ]; then
            state="$yellow" # work tree changes and/or untracked files
            break
        fi
    done
    IFS=$' \t\n'

    if [ -z "$branch" ]; then
        # git invocation failed, likely not inside a git work tree, cancel prompt injection.
        [ "$_BASHGIT_PS1_ORIG" ] && PS1=$_BASHGIT_PS1_ORIG
        return 2
    elif [ "$branch" = HEAD ]; then
        # Unknown branch/detached HEAD, try git describe
        branch="$(git describe HEAD --always --tags 2>/dev/null)" || branch=HEAD
    fi

    local remote=
    if [ "$remote_state" ] && [ "$showremote" ]; then
        remote="|${dark_gray}${remote_state}${state}"
    fi

    # Branch name truncation
    if [ $branchlimit -gt 0 ] && [ ${#branch} -gt $branchlimit ]; then
        pattern='^([^/]*)/(.*)$'
        if [[ ${branch} =~ $pattern ]]; then
            local branch_prefix=${BASH_REMATCH[1]}
            local branch_name=${BASH_REMATCH[2]}
            if [ ${#branch_prefix} -gt 3 ]; then
                branch="${branch_prefix:0:3}/${branch_name}"
            fi
        fi
        if [ ${#branch} -gt $branchlimit ]; then
            branch="${branch:0:${branchlimit}}.."
        fi
    fi

    # Update current PS1
    local bashgit="${state}[${branch}${remote}]${color_none}"
    case $_BASHGIT_PS1_ORIG in
        *'\$ ') PS1="${_BASHGIT_PS1_ORIG%\\\$ }${bashgit}\\\$ " ;;
        *'$ ') PS1="${_BASHGIT_PS1_ORIG%\$ }${bashgit}\$ " ;;
        *'# ') PS1="${_BASHGIT_PS1_ORIG%# }${bashgit}# " ;;
        *) PS1="${_BASHGIT_PS1_ORIG}${bashgit} " ;;
    esac
    _BASHGIT_PS1_PREV=$PS1
}

# Invoke git status before prompt display:
if [ "${PROMPT_COMMAND//_bashgit_update_ps1}" = "$PROMPT_COMMAND" ]; then
    PROMPT_COMMAND="${PROMPT_COMMAND:+${PROMPT_COMMAND%;}; }_bashgit_update_ps1;"
fi
